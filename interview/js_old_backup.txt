(function() {
   var a = b = 5;
})();
 
console.log(b); // 5, cause b was in global scope
if was var b = 5; - we got b - is not defined 

----------------------------------------------------

class Super {
	helloSuper() {
  	console.log("hello from super");
  }
}

class Child extends Super {
	helloChild() {
  	console.log("hello from child");
  }
}

const obj = new Child();

obj.hellosuper(); //  конструктор вызывается под капотом с методом супер

------------------------------------------------------

var i = 0;

function f() {
	### var i = undefined; // потому что c hoisting var вспывет ннаверх
	console.log(i); // выведет undefined
  	var i = 1; // и потом присвоит i
}

f(); // undefined

---------------------------------------------------------

let i = 0;

function f() {
	console.log(i); // i is not defined
    let i = 1;
}

f();

-------------------------------------------------------

console.log(1);
setTimeout(() => console.log(4), 0);
Promise.resolve().then(() => console.log(3));
console.log(2);

// 1 2 3 4

--------------------------------------------------------

Garbage collector:

Для очистки памяти от недостижимых значений используется автоматический Сборщик мусора, 
который наблюдает за объектами и время от времени удаляет недостижимые.

Самая простая ситуация здесь с примитивами. При присвоении они копируются целиком, 
ссылок на них не создаётся, так что если в переменной была одна строка,
а её заменили на другую, то предыдущую можно смело выбросить.

была создана ссылка в переменной, и эту переменную тут же перезаписали:

var user = {
  name: "Вася"
};
user = null;

Теперь объект { name: "Вася" } более недоступен. Память будет освобождена.

--------------------------------------------------------

const p = new Promise((res) => {res(42)});

p.then(console.log);
console.log(2);

---------------------------------------------------------

Js question:
Можно ли из js менять значения в before, after?

Ответ
Нет, единственное что мы можем — это удалить класс, у которого указаны before или after, либо наоборот добавить.

-----------------------------------------------

That comparison by reference basically checks to see if the objects given refer to the same location in memory

console.log(bobaFett == jangoFett);
// Outputs: false

-----------------------------------------------

Decorator - это как функция обертка которая может принимать в себя функцию и изменять ее поведение или класс и менять его свойства

Fasad - это абстрактный класс за которым скрывается реализация общих методов

Strategy - функция принимает аргументы в зависимости от которых меняет свое поведение, на пример мы можем первым аргументом передать функцию которая будет выводить следующие аргументы в консоль или другую функцию которая будет выводить их на экран, вообщем в зависимости от переданных функция меняется стратегия поведение главной функции

Factory - это класс который в зависимости от аргументы создает различные объекты

-----------------------------------------------------

Можно ли у класса переопределять метод

Менять методы класса невозможно возможно только для его прототипа

class Person {
	constructor(name) {
  	this.name = name;
  }
	getName() {
  	console.log(this.name);
  }
}

const person = new Person("Yura");

// меняем метод у прототипа
Person.prototype.sayHello = () => console.log("hello");
Person.sayBy = () => console.log("by");

// доступно в person потому что та наследуется от прототипа
person.sayHello()

-------------------------------------------

unit tests -> must to be isolated (for this tou can use mock data)

---------------------------------------------

settimeout vs promise 

Вызов setTimeout добавит событие в очередь по прошествии времени, 
указанного во втором аргументе вызова. Если очередь событий на тот момент 
будет пуста, то событие обработается сразу же, в противном случае событию 
функции setTimeout придется ожидать завершения обработки остальных событий 
в очереди. Именно поэтому второй аргумент setTimeout корректно считать не 
временем, через которое выполнится функция из первого аргумента, а 
минимальное время, через которое она сможет выполниться.

-------------------------------------------------

Ассоциация – это когда один класс включает в себя другой класс в качестве одного из полей. Ассоциация описывается словом «имеет».
Композиция – это когда двигатель не существует отдельно от автомобиля. Он создается при создании автомобиля и полностью управляется автомобилем. В типичном примере, экземпляр двигателя будет создаваться в конструкторе автомобиля. 
Агрегация – это когда экземпляр двигателя создается где-то в другом месте кода, и передается в конструктор автомобиля в качестве параметра. 

------------------------------------

const a = [Array(100)].map((i, index) => i);
console.log(a[0]) 

-> 
When you create a new array with the Array constructor, it creates a new array object with its length property 
set to the value you passed in, but otherwise the object is a vacuum. There are no index keys 
in the object representation of the array whatsoever.

{
  //no index keys!
  length: 100
}

-> Solution

const arr = [...Array(100)].map((_, i) => i);

-------------------------------------------

--------------------------------------------------

if ( 5 > n) { 
  console.log(1)
}

// or

if ( 5 > n ) console.log(1)

---------------------------------------------

// how think js interpretation
 -> when you use this construction 2.toString() -> js interpretation create new Streing for 2 and create new string object and then use method toString

----------------------------------------------

typeof return a string

-------------------------------------------------

Object.entries()

Метод Object.entries() возвращает, массив, 
содержащий массивы, представляющие собой пары вида [ключ, значение];

const weather = {
  rain: 0,
  temperature: 24,
  humidity: 33,
}

const entries = Object.entries(weather); // [['rain', 0], ['temperature', 24], ['humidity', 33]];



---------------------------------------------------

Object.freeze()

Метод Object.freeze() «замораживает» объект, предотвращая изменение существующих свойств этого объекта или добавление новых свойств и значений в объект.

const frozenObject = {
  name: 'Robert'
}

Object.freeze(frozenObject);

frozenObject.name = 'Henry'; // объект frozenObject не изменится, он сохранится в виде { name: 'Robert' }

--------------------------------------------------------

Object.seal()

Метод Object.seal() позволяет «запечатать» объект, предотвратив добавление новых свойств. При этом существующие свойства можно менять.

const sealedObject = {
  name: 'Robert'
}

Object.seal(sealedObject);

sealedObject.name = 'Bob';
sealedObject.wearsWatch = true; // объект sealedObject будет выглядеть так: { name: 'Bob' }

----------------------------------------------------------

create error in js and try catch

const some = (n) => {
	if(n > 10) throw new Error("n must be less than 10");
  
  return n + 1;
};

try {
	console.log(some(11));
}
catch(e) {
	console.log('you got an error ->', e);
}

------------------------------------------------

uncauth error if in code js can`t finde try catch for processing error

--------------------------------------------------------

const test = {
    age: 42
};
Object.preventExtensions(test);
test.name = 5;

console.log(test); // undefined

---------------------------------------------

const result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 .filter(int => isEven(int));

 -> 

const result = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
 .filter(isEven);

 -------------------------------------

 const csum = a => b => a + b
sum(1)(2)

csum(1)
// b => 1 + b

const plusOne = csum(1)
plusOne(2)
// 3

----------------------------------------

inheritance es5

const a = {
	name: "name"
}


const b = Object.create(a)

console.dir(b.name)
console.log(b.hasOwnProperty(b.name)) - false

----------------------------------------------

что будет если в одном из запросов произойдет ошибка, довыполнится ли цепочка?

Нет

------------------------------------------------

function Book(name, author) {
    this.name = name;
    this.author = author;
    return this;
}

function Book(name, author) {
    this.name = name;
    this.author = author;
    return this;
}

function Foo(obj, name, author) {
    return obj.call({}, name, author);
}

const book = Foo(Book, 'js', 'petr');

---------------------------------------

то что null это object это баг typeof null это null

-------------------------------------

наследование в js отличается от обычного тем что у объкта при наследовании нет своих свойст
они наследуются от протитипа

class Car {
	drive() {
  	console.log('car is driving');
  }
}

class Mitsubisi extends Car {
	
}

console.log(Car.prototype.hasOwnProperty('drive')); // true
console.log(Mitsubisi.prototype.hasOwnProperty('drive')); // false

---------------------------

Что такое всплытие событий и чем оно отличается от перехвата событий?

сплытие событий используется при реализации делегирования событий. Если подписаться на события родительского элемента, можно получить сведения о событиях и для его потомков

И перехват, и всплытие событий являются частью процесса, который называется «распространение событий»,
в ходе которого браузер реагирует на события, происходящие на странице. Более старые браузеры выполняли либо одно,
либо другое, но в наши дни все браузеры поддерживают и перехват, и всплытие событий.

Первая фаза — фаза перехвата — выполняется сразу после того, как происходит событие. Событие начинается
на самом верхнем уровне, которым является либо объект document, либо объект window в зависимости от события.
Отсюда оно опускается, проходя через тег <html> и через то, что находится в этом теге, до тех пор, пока не достигнет элемента, в пределах которого оно возникло.

Затем происходит вторая фаза — всплытие события. В её ходе повторяется тот же процесс, но наоборот.
Всё начинается с элемента, который вызвал событие, оно «всплывает» до корневого элемента <html>.
При добавлении прослушивателей событий ожидается именно такое поведение системы.

--------------------------------

Как делегирование событий улучшает код на сайтах с множеством интерактивных элементов?

Веб-сайты нередко полны динамических элементов, которые постоянно меняются. 
Если подобные элементы должны быть ещё и интерактивными, понадобится некий способ 
наблюдения за событиями, которые возникают, когда пользователь с ними взаимодействует. 
Если каждому элементу понадобится собственный прослушиватель событий, это замусорит 
код и увеличит нагрузку на браузер.

Делегирование событий — это техника, которая использует механизм всплытия событий. 
Добавляя прослушиватель к родительскому элементу, разработчик может наладить 
обработку событий для его потомков.

parentEl.addEventListener('click', function(e) {
  if(e.target && e.target.nodeName == 'BUTTON') {
  // Щелчок по кнопке
  } });

Внутри функции обратного вызова прослушивателя события целевой элемент события будет 
представлен параметром target, который можно использовать для принятия решения о 
дальнейших действиях. Например, атрибут этого параметра data может хранить идентификатор для доступа к свойствам объекта.

-----------------------------------

const someObject = {};

(( someObject ) => {
    someObject.value = 10;
    someObject = null;
})( someObject );

console.log(someObject); // будует {value: 10} так как мы передаем ссылку на объект, и мы можем у ссылки менять только свойства, но не сам объект

->

const someObject = {};

(( someObject ) => {
		let no = someObject;
    no.value = 10;
    no = null;
    console.log(no); // вот тут будет null, так как мы помещаем ссылку на оъект в переменную и нам этот объект доступен по этой сылке и мы ее перезатираем
})( someObject );


-----------------------------------------

const someObject = {
  objectFunction: function() {
    console.log(this.prop);
  },
  prop: 1
};

someObject.objectFunction.prop = 2; // строка чтобы запутать

someObject.objectFunction(); // в этом логе будет 1, так как сохраняется контекст

const fn = someObject.objectFunction;
fn(); // тут будет undefined, так как контекст будет window, У объекта window нет свойства prop, соответственно, в консоли получаем undefined.


-------------------------------------------
1. case:
function a () {
    return console.log (a); // and second argument is var a not will be assign after return, because after return function end his execute
    var a = 5; // will be undefined, because a hoisted to upper scopoe and there get value undefined
};
a();

2. case:
function a () {
    return console.log (a)
    let a = 5;
};
a();


---------------------------------------------------

const person = {
  name: 'Yura',
  born: 1990
}

person.__proto__ = {
  age: function() {
    return 2018 - this.born;
  }
}

person.age = function() {
  return 2018 - this.born + ' лет';
}

console.log( person.age() ); // 28лет
// потому что мы присваеваем метод age персоне и она не поднимается выше по прототипу и и спользует свой метод

// а вот если 

person.__proto__ = {
  ageFromProto: function() {
    return 1;
  }
}

person.age = function() {
  return 2018 - this.born + ' лет';
}

console.log( person.ageFromProto() ); // 1 
// потому что идем вверх по прототипу

-------------------------------------------------

var count = 0;
function f() {
  count++;

  return f;
}

f.valueOf = function() {
  return count;
}

console.log( f() == 1 ); // true

console.log( f() === 1 ); // true
console.log( f()() === 3 ); // true
console.log( f()()() === 6 ); // true

----------------------------------------------------

let count = 0;
const f = () => {
	if(count === 0) {
  	count = 1;
  	return count;
  }
  
  return () => {
  	count += 2;
    return count;
  }
}


console.log( f() ); // 1
console.log( f()() ); // 3

------------------------------------------------------
-- с прототипами нужно помнить: на запись — только собственные свойства, а на чтение — можно и из родителя.

var obj = {
    a: 5,
    b: {
        c: 10
    }
};

// Ну первое, что нельзя не прокомментировать - это задание прототипа через свойство __proto__, в 2k18 это не очень правильно. 
obj.__proto__ = {
    a: 10,
    b: {
        c: 20
    }
};

delete obj.a;
console.log(obj.a); // будет 10, так как этого свйоства больше нет у объекта и мы берем значение из прототипа

delete obj.a;
console.log(obj.a); // тоже самое

delete obj.b;
console.log(obj.b.c); // будет 20, тоже самое

delete obj.b.c;
console.log(obj.b.c); 
// В консоль выведется undefined, и получается, что таки можно залезть в прототип и что-то там поменять.
Этот эффект объясняется очень просто: в обращении obj.b.c та часть, которая обращается к прототипу obj.b делает это на чтение, 
и мы получаем прямую ссылку на объект и уже из него удаляем собственное свойство с.

--------------------------------------------------

const a = {};
const b = {key: 'b'};
const c = {key: 'c'};

a[b] = 12;
a[c] = 42; // тут a['[object Object]'] перезаписываем значение

console.log(a[b]); // будет 42, так как ключом у объектов в js может быть строка, а значить а[b] === a['[object Object]'] - так как идет преобразование в toString

---------------------------------------------------

const test = 42;

const a = () => {
    console.log(test);
}

const b = () => {
    var test = 13;
    a();
}

a(); // 42

Создаём глобальную переменную test, ей присваивается значение 42. 
Объявляем функцию a, её свойство [[Scope]] ссылается на глобальный объект window. 
Объявляем функцию b, внутри которой создаём переменную test со значением 13, и вызываем функцию a.
При вызове функции b внутри нее создается свой Lexical Environment, в которую записывается test = 13.
Вызываем функцию a: интерпретатор ищет внутри функции a (то есть в её Lexical Environment) переменную test, 
не находит её и идёт по ссылке [[Scope]]. Путь приводит его в глобальную область видимости, 
где он и находит переменную test со значением 42, что и выводит в консоль.

-------------------------------------------------------

(function(){
		const array = [2,2,2,2].map(parseInt); // -> map((currentValue, index) => parseInt(currentValue, index));, radix = 1 - допускается значение radix от 2 до 36, NaN
		console.log(array);
})()

Мораль такова, что вызывать функции нужно с явным указанием параметров, а не абы как.

При вызове в функцию Array.map передаются следующие параметры: currentValue, index, array

А у глобального метода parseInt два параметра:
string, radix - причем radix является обязательным параметром, если его не указывать возможны непредсказуемые результаты

----------------------------------------------------------

function X() {}
function Y() {}  
 
Y.prototype = Object.create(X.prototype); //  -> тут перезаписываем функцию
var z = new Y();

console.log(z.constructor === Y); // false, так как -> 

/*---------------------------------------------*/

RESTful API Design
------------------
1. Use nouns and NOT the verbs cause HTTP methods with us to describe the APIs better:

  /getAllProducts --> /products

2. Use Plurals

/products or /product:

This topic is bit debatable.

I like to keep it plural since it avoid confusion whether we are talking about getting single resource or collection.
It also avoids adding additional things like attaching all to the base URL e.g. /product/all

Some people might not like this but my only suggestion is to keep is uniform across the project.

3. Use parameters

  - /products?name=’ABC’ should be preffered over /getProductsByName

/*----------------------------------------------*/

Вопрос: Чему равно foo.x?

let foo = {
  n: 1
};

foo.x = foo = {n: 2}; // undefined, потому что foo переопределяется и у него нет x, а значит и нельзя ему ничего присвоить

-------------------------------------------------

В чем заключается разница между классовым и прототипным наследованием?
Классовое наследование: экземпляры наследуются от классов, создаются подклассовые отношения (иерархическая систематизация классов). Экземпляры реализуются через конструктор функции, через дескриптор new. Экземпляр класса может не содержать дескриптор class начиная с ES6.

Прототипное наследование: экземпляры наследуются напрямую от других объектов, реализуются через фабрики или Object.create() и экземпляры могут быть составлены из множества различных объектов для упрощения выборочного наследования. Прототипное наследование более простое и гибкое, нежели классовое.

Хорошо упомянуть:

1. Классы: тесные связи, иерархия

2. Прототипы: конкатенативное наследование, делегирование, функциональное наследование, композиция

Следует избегать:

Не указать на преимущества прототипного наследования перед классовым

------------------------------------------------------

Когда классовое наследование – подходящий выбор?
Вопрос с подвохом. Правильный ответ – никогда. Композиция – более простой и гибкий подход, чем наследование классов.

Хорошо упомянуть

«…композиция объектов лучше, чем наследование классов»

---------------------------------------------------------

Что значит «композиция объектов лучше, чем наследование классов»?
Это цитата из книги “Design Patterns: Elements of Reusable Object-Oriented Software”. 
Повторное использование кода должно достигаться за счет сборки малых единиц функциональности в 
новый объект, а не наследованием классов и созданием иерархий.

Хорошо упомянуть:

1. Избежание наследования и тесных связей

2. Избежание вытекающей из классического наследования проблемы «банан/мартышка» (нужен был банан – 
получили мартышку, держащую банан посреди джунглей)

----------------------------------------------------------

Что такое двусторонняя связь данных и однонаправленный поток данных и в чем разница между ними?
Двусторонняя связь данных подразумевает, что поля интерфейса связаны с моделью данных динамически, 
то есть при изменении полей интерфейса меняется модель, и наоборот.

Однонаправленный поток данных означает, что только модель – источник истины. 
Изменения в интерфейсе запускают сообщения, которые сигнализируют пользователю о 
намерении модели (или «store» в терминах React). Смысл в том, что данные всегда 
идут в одном направлении, что облегчает понимание.

Односторонние потоки данных детерминированы, тогда как двусторонняя привязка может 
вызывать нежелательные эффекты, которые труднее отследить и понять.

Хорошо упомянуть:

1. React – новый канонический пример однонаправленного потока данных, так что упоминание 
Реакта будет хорошей идеей. Cycle.js — еще одна популярная реализация однонаправленного потока данных.

2. Angular – популярный фреймворк, использующий двустороннюю привязку.

--------------------------------------------------

В чем разница между Object.getOwnPropertyNames() и Object.keys()

Object.getOwnPropertyNames() возвращает перечислимые и не перечислимые свойства из объекта или массива.
var arr = ["a", "b", "c"]; 
print(Object.getOwnPropertyNames(arr).sort()); // prints "0,1,2,length" 

Object.keys() возвращает перечислимые свойства из объекта или массива.

var arr = ["a", "b", "c"]; 
alert(Object.keys(arr)); // will alert "0,1,2" 

----------------------------------------------

var a = 90100; 
function someFunc(){ 
  if(false){ 
    var a = 1; 
  } else { 
    var b = 2; 
  } 
  
  console.log(a); // undefined because hoisting
} 
someFunc(); 

--------------------------------------------------

const array = [3, 4, 5]; 
for (let i in array){ 
  console.log(i); // 0, 1, 2 because show keys 
} 

---------------------------------------------------

Неверно считать, что числовые литералы нельзя использовать в качестве объектов — это распространённое заблуждение. Его причиной является упущение в парсере JavaScript, благодаря которому применение точечной нотации к числу воспринимается им как литерал числа с плавающей точкой.

2.toString(); // вызывает SyntaxError
Есть несколько способов обойти этот недостаток и любой из них можно использовать для того, чтобы работать с числами, как с объектами:

2..toString(); // вторая точка распознаётся корректно
2 .toString(); // обратите внимание на пробел перед точкой
(2).toString(); // двойка вычисляется заранее